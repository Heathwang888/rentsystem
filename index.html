require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

const app = express();
const port = process.env.PORT || 3000;

// 設置 Mongoose strictQuery
mongoose.set('strictQuery', false);

// MongoDB 連接
const mongoUri = process.env.MONGODB_URI;
console.log('Connecting to MongoDB at:', mongoUri.replace(/\/\/[^@]+@/, '//****:****@'));

mongoose.connect(mongoUri, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('Connected to MongoDB Atlas'))
.catch(err => {
  console.error('MongoDB connection error:', err);
  process.exit(1);
});

// 定義客戶資料模型
const customerSchema = new mongoose.Schema({
  name: { type: String, required: true },
  idNumber: { type: String, required: true },
  phone: { type: String, required: true },
  address: { type: String, required: true },
  contactAddress: { type: String },
  model: { type: String, required: true },
  imei: { type: String, required: true },
  screenPassword: { type: String },
  salePrice: { type: Number, required: true },
  rent: { type: Number, required: true },
  contractDate: { type: Date, required: true },
  files: {
    contractFile: String,
    idFront: String,
    idBack: String
  },
  status: { type: String, default: 'renting' },
  createdAt: { type: Date, default: Date.now },
  lastPaymentDate: { type: Date },
  paymentRecords: [{
    date: { type: Date, required: true },
    amount: { type: Number, required: true }
  }],
  paidAmount: { type: Number, default: 0 },
  unpaidAmount: { type: Number, default: 0 },
  notes: { type: String },
  buybackDate: { type: Date },
  lockDate: { type: Date }
});

const Customer = mongoose.model('Customer', customerSchema, 'customers');

// 中間件設置
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// 根路由處理
app.get('/', (req, res) => {
  res.send('Phone Contract Management API is running');
});

// 設置文件上傳
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = 'uploads';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 限制文件大小為 5MB
  }
});

// API 路由

// 獲取客戶列表（分頁）
app.get('/api/customers', async (req, res) => {
  try {
    const { page = 1, limit = 5 } = req.query;
    const skip = (page - 1) * limit;
    
    const customers = await Customer.find()
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    const total = await Customer.countDocuments();
    
    res.json({
      customers,
      total,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    res.status(500).json({ error: '獲取客戶列表失敗' });
  }
});

// 搜尋客戶
app.get('/api/customers/search', async (req, res) => {
  try {
    const { q } = req.query;
    const { page = 1, limit = 5 } = req.query;
    const skip = (page - 1) * limit;
    
    const query = {
      $or: [
        { name: { $regex: q, $options: 'i' } },
        { idNumber: { $regex: q, $options: 'i' } },
        { phone: { $regex: q, $options: 'i' } }
      ]
    };
    
    const customers = await Customer.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    const total = await Customer.countDocuments(query);
    
    res.json({
      customers,
      total,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    res.status(500).json({ error: '搜尋客戶失敗' });
  }
});

// 創建新客戶
app.post('/api/customers', upload.fields([
  { name: 'contractFile', maxCount: 1 },
  { name: 'idFront', maxCount: 1 },
  { name: 'idBack', maxCount: 1 }
]), async (req, res) => {
  try {
    console.log('Received request body:', req.body);
    console.log('Received files:', req.files);

    // 驗證必填欄位
    const requiredFields = ['name', 'idNumber', 'phone', 'address', 'phoneModel', 'imei', 'price', 'rent', 'contractDate'];
    for (const field of requiredFields) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `缺少必填欄位: ${field}` });
      }
    }

    // 轉換數值類型
    const customerData = {
      name: req.body.name,
      idNumber: req.body.idNumber,
      phone: req.body.phone,
      address: req.body.address,
      contactAddress: req.body.mailingAddress,
      model: req.body.phoneModel,
      imei: req.body.imei,
      screenPassword: req.body.screenPassword,
      salePrice: parseFloat(req.body.price),
      rent: parseFloat(req.body.rent),
      contractDate: new Date(req.body.contractDate),
      files: {
        contractFile: req.files?.contractFile?.[0]?.filename || null,
        idFront: req.files?.idFront?.[0]?.filename || null,
        idBack: req.files?.idBack?.[0]?.filename || null
      }
    };

    console.log('Processed customer data:', customerData);

    const customer = new Customer(customerData);
    await customer.save();
    
    res.status(201).json(customer);
  } catch (error) {
    console.error('Error creating customer:', error);
    res.status(500).json({ 
      error: '創建客戶失敗',
      details: error.message 
    });
  }
});

// 更新客戶資訊
app.put('/api/customers/:id', async (req, res) => {
  try {
    const customer = await Customer.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    res.json(customer);
  } catch (error) {
    res.status(500).json({ error: '更新客戶失敗' });
  }
});

// 更新客戶狀態
app.patch('/api/customers/:id/status', async (req, res) => {
  try {
    const { status, paidAmount, unpaidAmount } = req.body;
    const updateData = { status };
    
    if (status === 'partial' && paidAmount && unpaidAmount) {
      updateData.paidAmount = paidAmount;
      updateData.unpaidAmount = unpaidAmount;
    }
    
    const customer = await Customer.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    );
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    res.json(customer);
  } catch (error) {
    console.error('Error updating customer status:', error);
    res.status(500).json({ error: '更新客戶狀態失敗' });
  }
});

// 更新客戶備註
app.patch('/api/customers/:id/notes', async (req, res) => {
  try {
    const { notes } = req.body;
    const customer = await Customer.findByIdAndUpdate(
      req.params.id,
      { notes },
      { new: true }
    );
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    res.json(customer);
  } catch (error) {
    console.error('Error updating customer notes:', error);
    res.status(500).json({ error: '更新客戶備註失敗' });
  }
});

// 刪除客戶
app.delete('/api/customers/:id', async (req, res) => {
  try {
    const customer = await Customer.findById(req.params.id);
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    // 刪除相關文件
    if (customer.files) {
      Object.values(customer.files).forEach(filename => {
        if (filename) {
          const filePath = path.join('uploads', filename);
          if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
          }
        }
      });
    }
    
    await customer.remove();
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: '刪除客戶失敗' });
  }
});

// 獲取客戶文件
app.get('/api/customers/:id/files/:type', async (req, res) => {
  try {
    const customer = await Customer.findById(req.params.id);
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    let filePath;
    if (req.params.type === 'contract') {
      if (!customer.files?.contractFile) {
        return res.status(404).json({ error: '合約文件不存在' });
      }
      filePath = path.join('uploads', customer.files.contractFile);
    } else if (req.params.type === 'id') {
      if (!customer.files?.idFront || !customer.files?.idBack) {
        return res.status(404).json({ error: '身分證文件不存在' });
      }
      // 這裡可以實現合併 PDF 的邏輯，暫時只返回正面
      filePath = path.join('uploads', customer.files.idFront);
    } else {
      return res.status(400).json({ error: '無效的文件類型' });
    }
    
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: '文件不存在' });
    }
    
    res.sendFile(path.resolve(filePath));
  } catch (error) {
    console.error('Error getting customer file:', error);
    res.status(500).json({ error: '獲取文件失敗' });
  }
});

// 處理繳款
app.post('/api/customers/:id/payment', async (req, res) => {
  try {
    const { amount } = req.body;
    if (!amount || amount <= 0) {
      return res.status(400).json({ error: '無效的繳款金額' });
    }

    const customer = await Customer.findById(req.params.id);
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }

    // 更新繳款記錄
    if (!customer.paymentRecords) {
      customer.paymentRecords = [];
    }

    customer.paymentRecords.push({
      date: new Date(),
      amount: amount
    });

    // 更新最後繳款日期
    customer.lastPaymentDate = new Date();

    // 如果有未付金額，則更新
    if (customer.unpaidAmount) {
      customer.unpaidAmount = Math.max(0, customer.unpaidAmount - amount);
    }

    await customer.save();
    res.json(customer);
  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ error: '處理繳款失敗' });
  }
});

// 買回處理
app.post('/api/customers/:id/buyback', async (req, res) => {
  try {
    const customer = await Customer.findByIdAndUpdate(
      req.params.id,
      { 
        status: 'buyback',
        buybackDate: new Date()
      },
      { new: true }
    );
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    res.json(customer);
  } catch (error) {
    console.error('Error processing buyback:', error);
    res.status(500).json({ error: '處理買回失敗' });
  }
});

// 呆帳鎖機處理
app.post('/api/customers/:id/lock', async (req, res) => {
  try {
    const customer = await Customer.findByIdAndUpdate(
      req.params.id,
      { 
        status: 'locked',
        lockDate: new Date()
      },
      { new: true }
    );
    
    if (!customer) {
      return res.status(404).json({ error: '客戶不存在' });
    }
    
    res.json(customer);
  } catch (error) {
    console.error('Error processing lock:', error);
    res.status(500).json({ error: '處理鎖機失敗' });
  }
});

// 錯誤處理中間件
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: '伺服器錯誤' });
});

// 啟動伺服器
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
}); 
